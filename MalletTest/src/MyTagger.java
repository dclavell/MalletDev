import java.io.File;
import java.io.FileReader;
import java.io.Reader;
import java.util.ArrayList;
import java.util.regex.Pattern;

import cc.mallet.fst.CRF;
import cc.mallet.fst.CRFOptimizableByLabelLikelihood;
import cc.mallet.fst.CRFTrainerByValueGradients;
import cc.mallet.fst.CRFWriter;
import cc.mallet.fst.MultiSegmentationEvaluator;
import cc.mallet.fst.TransducerEvaluator;
import cc.mallet.fst.TransducerTrainer;
import cc.mallet.optimize.Optimizable;
import cc.mallet.pipe.Pipe;
import cc.mallet.pipe.iterator.LineGroupIterator;
import cc.mallet.types.Alphabet;
import cc.mallet.types.FeatureVector;
import cc.mallet.types.FeatureVectorSequence;
import cc.mallet.types.Instance;
import cc.mallet.types.InstanceList;
import cc.mallet.types.LabelAlphabet;
import cc.mallet.types.LabelSequence;

public class MyTagger {

	public static void main(String[] args) throws Exception {
		// Generate the InstanceLists of training/testing data.
		// Pipe instancePipe = new
		Reader trainingFile = new FileReader(new File("E:\\stuff.txt"));
		Reader testFile = new FileReader(new File("E:\\stuff.txt"));
		Pipe pTrain = new MyTaggerSentence2FeatureVectorSequence();
		Pipe pTest = new MyTaggerSentence2FeatureVectorSequence();
		pTrain.getTargetAlphabet().lookupIndex("000");
		pTrain.setTargetProcessing(true);
		pTest.getTargetAlphabet().lookupIndex("000");
		pTest.setTargetProcessing(true);
		InstanceList trainingData = new InstanceList(pTrain);
		InstanceList testData = new InstanceList(pTrain);
		testData.addThruPipe(new LineGroupIterator(testFile, Pattern
				.compile("^\\s*$"), true));
		trainingData.addThruPipe(new LineGroupIterator(trainingFile, Pattern
				.compile("^\\s*$"), true));
		System.out.println("Number of features in training data: "
				+ pTrain.getDataAlphabet().size());
		System.out.println(pTrain.getTargetAlphabet());
		// What are start/continue tags?
		// Needs more setup to train?
		new MyTagger().run(trainingData, testData);
	}

	public void run(InstanceList trainingData, InstanceList testingData) {
		// setup:
		// CRF (model) and the state machine
		// CRFOptimizableBy* objects (terms in the objective function)
		// CRF trainer
		// evaluator and writer

		// model
		CRF crf = new CRF(trainingData.getDataAlphabet(),
				trainingData.getTargetAlphabet());
		// construct the finite state machine
		crf.addFullyConnectedStatesForLabels();
		// initialize model's weights
		crf.setWeightsDimensionAsIn(trainingData, false);

		// CRFOptimizableBy* objects (terms in the objective function)
		// objective 1: label likelihood objective
		CRFOptimizableByLabelLikelihood optLabel = new CRFOptimizableByLabelLikelihood(
				crf, trainingData);

		// CRF trainer
		Optimizable.ByGradientValue[] opts = new Optimizable.ByGradientValue[] { optLabel };
		// by default, use L-BFGS as the optimizer
		CRFTrainerByValueGradients crfTrainer = new CRFTrainerByValueGradients(
				crf, opts);

		// *Note*: labels can also be obtained from the target alphabet
		String[] labels = new String[] { "norm", "silly", "curse", "jibberish"};
		TransducerEvaluator evaluator = new MultiSegmentationEvaluator(
				new InstanceList[] { trainingData, testingData }, new String[] {
						"train", "test" }, labels, labels) {
			@Override
			public boolean precondition(TransducerTrainer tt) {
				// evaluate model every 5 training iterations
				return tt.getIteration() % 5 == 0;
			}
		};
		crfTrainer.addEvaluator(evaluator);

		CRFWriter crfWriter = new CRFWriter("ner_crf.model") {
			@Override
			public boolean precondition(TransducerTrainer tt) {
				// save the trained model after training finishes
				return tt.getIteration() % Integer.MAX_VALUE == 0;
			}
		};
		crfTrainer.addEvaluator(crfWriter);

		// all setup done, train until convergence
		crfTrainer.setMaxResets(0);
		crfTrainer.train(trainingData, Integer.MAX_VALUE);
		// evaluate
		evaluator.evaluate(crfTrainer);

		// save the trained model (if CRFWriter is not used)
		// FileOutputStream fos = new FileOutputStream("ner_crf.model");
		// ObjectOutputStream oos = new ObjectOutputStream(fos);
		// oos.writeObject(crf);
	}

	public static class MyTaggerSentence2FeatureVectorSequence extends Pipe {
		// gdruck
		// Previously, there was no serialVersionUID. This is ID that would
		// have been automatically generated by the compiler. Therefore,
		// other changes should not break serialization.
		private static final long serialVersionUID = -2059308802200728625L;

		/**
		 * Creates a new <code>SimpleTaggerSentence2FeatureVectorSequence</code>
		 * instance.
		 */
		public MyTaggerSentence2FeatureVectorSequence() {
			super(new Alphabet(), new LabelAlphabet());
		}

		/**
		 * Parses a string representing a sequence of rows of tokens into an
		 * array of arrays of tokens.
		 * 
		 * @param sentence
		 *            a <code>String</code>
		 * @return the corresponding array of arrays of tokens.
		 */
		private String[][] parseSentence(String sentence) {
			String[] lines = sentence.split("\n");
			String[][] tokens = new String[lines.length][];
			for (int i = 0; i < lines.length; i++)
				tokens[i] = lines[i].split(" ");
			// Instead, parse them into the XYZ positions of each joint.

			// Joint Places:
			//			
			// HIP_CENTER = 0;
			// SPINE = 1;
			// SHOULDER_CENTER = 2;
			// HEAD = 3;
			// SHOULDER_LEFT = 4;
			// ELBOW_LEFT = 5;
			// WRIST_LEFT = 6;
			// HAND_LEFT = 7;
			// SHOULDER_RIGHT = 8;
			// ELBOW_RIGHT = 9;
			// WRIST_RIGHT = 10;
			// HAND_RIGHT = 11;
			// HIP_LEFT = 12;
			// KNEE_LEFT = 13;
			// ANKLE_LEFT = 14;
			// FOOT_LEFT = 15;
			// HIP_RIGHT = 16;
			// KNEE_RIGHT = 17;
			// ANKLE_RIGHT = 18;
			// FOOT_RIGHT = 19
			//
			// Joint Connections:
			//
			// HIP_CENTER, SPINE; ...
			// SPINE, SHOULDER_CENTER; ...
			// SHOULDER_CENTER, HEAD; ...
			// % Left arm ...
			// SHOULDER_CENTER, SHOULDER_LEFT; ...
			// SHOULDER_LEFT, ELBOW_LEFT; ...
			// ELBOW_LEFT, WRIST_LEFT; ...
			// WRIST_LEFT, HAND_LEFT; ...
			// % Right arm ...
			// SHOULDER_CENTER, SHOULDER_RIGHT; ...
			// SHOULDER_RIGHT, ELBOW_RIGHT; ...
			// ELBOW_RIGHT, WRIST_RIGHT; ...
			// WRIST_RIGHT, HAND_RIGHT; ...
			// % Left leg ...
			// HIP_CENTER, HIP_LEFT; ...
			// HIP_LEFT, KNEE_LEFT; ...
			// KNEE_LEFT, ANKLE_LEFT; ...
			// ANKLE_LEFT, FOOT_LEFT; ...
			// % Right leg ...
			// HIP_CENTER, HIP_RIGHT; ...
			// HIP_RIGHT, KNEE_RIGHT; ...
			// KNEE_RIGHT, ANKLE_RIGHT; ...
			// ANKLE_RIGHT, FOOT_RIGHT ...
			return tokens;
		}

		public Instance pipe(Instance carrier) {
			Object inputData = carrier.getData();
			Alphabet features = getDataAlphabet();
			LabelAlphabet labels;
			LabelSequence target = null;
			String[][] tokens;
			if (inputData instanceof String)
				tokens = parseSentence((String) inputData);
			else if (inputData instanceof String[][])
				tokens = (String[][]) inputData;
			else
				throw new IllegalArgumentException(
						"Not a String or String[][]; got " + inputData);
			FeatureVector[] fvs = new FeatureVector[tokens.length];
			if (isTargetProcessing()) {
				labels = (LabelAlphabet) getTargetAlphabet();
				target = new LabelSequence(labels, tokens.length);
			}
			for (int l = 0; l < tokens.length; l++) {
				int nFeatures;
				if (isTargetProcessing()) {
					if (tokens[l].length < 1)
						throw new IllegalStateException(
								"Missing label at line " + l + " instance "
										+ carrier.getName());
					nFeatures = tokens[l].length - 1;
					target.add(tokens[l][nFeatures]);
				} else
					nFeatures = tokens[l].length;
				ArrayList<Integer> featureIndices = new ArrayList<Integer>();
				for (int f = 0; f < nFeatures; f++) {
					int featureIndex = features.lookupIndex(tokens[l][f]);
					// gdruck
					// If the data alphabet's growth is stopped, featureIndex
					// will be -1. Ignore these features.
					if (featureIndex >= 0) {
						featureIndices.add(featureIndex);
					}
				}
				int[] featureIndicesArr = new int[featureIndices.size()];
				for (int index = 0; index < featureIndices.size(); index++) {
					featureIndicesArr[index] = featureIndices.get(index);
				}
				fvs[l] = new FeatureVector(features, featureIndicesArr);
			}
			carrier.setData(new FeatureVectorSequence(fvs));
			if (isTargetProcessing())
				carrier.setTarget(target);
			else
				carrier.setTarget(new LabelSequence(getTargetAlphabet()));
			return carrier;
		}
	}

}
